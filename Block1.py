from typing import Dict, Any
from random import choice

# EASY
# Дополнил логику функции, так чтобы в верхний регистр переводилаcь
# каждая нечетная позиция строки. Тогда мы можем передать любое число 
# в кач-ве аргумента, а каждое нечетное повторние строки будет в
# верхнем регистре

## Вариант 1. Через конкатенацию строк
def convert_reg_uneven_conc(txt: str, num: int) -> str:
    temp_str = ''
    for i in range(num):
        if not i % 2:
            temp_str += txt
        else:
            temp_str += txt.upper()
    return temp_str


## Вариант 2. Через списочное выражение и метод join
def convert_reg_uneven_lc(txt: str, num: int) -> str:
    temp_cont = [txt if not i % 2 else txt.upper() for i in range(num)]
    return "".join(temp_cont)

## Вариант 3. С дополнительным аргментом с булевым значением, который позволяет
## выбрать какую из позиций повторения строки переводить в верхний регистр
def convert_reg_choice(txt: str, num: int, even=False) -> str:
    temp_cont = [txt for _ in range(num)]
    for idx, item in enumerate(temp_cont):
        if even:
            if not idx % 2:
                temp_cont[idx] = item.upper()
        if idx % 2:
                temp_cont[idx] = item.upper()
    return "".join(temp_cont)


# Присваиваем переменным наши функции
strange_string_buider_1 = convert_reg_uneven_conc 
strange_string_buider_2 = convert_reg_uneven_lc
strange_string_buider_3 = convert_reg_choice

# Здесь печатаем переменные, которым присвоили значения
print(strange_string_buider_1)
# -> <function convert_reg_uneven_conc at 0x7f441257fd90>

print(strange_string_buider_2)
# -> <function convert_reg_uneven_lc at 0x7f4412010790>
# Получаем строки с представлением объектов, которые были 
# созданы при определении наших функций

# Здесь печатаем уже результат работы функций, который они
# возвращают 
print(strange_string_buider_1('test', 3))
# -> testTESTtest

print(strange_string_buider_2('othertest', 5))
# -> othertestOTHERTESTothertestOTHERTESTothertest
# На выходе имеем строки, полученные путем повторения 
# переданной в кач-ве аргумента строки, в количестве
# раз, также переданным вторым позиционным аргументом
# с применением дополнительной логики, а именно
# перевод нечетных повторений исходной строки в верхний
# регистр

####################################################################################

# MEDIUM

# 1. Функция, принимающая произвольное количество позиционных и именованных
# аргументов возвращает сумму переданных аргуметов. Добавил также проверку 
# типов передаваемых аргументов и возврат исключения в случае, если тип
# не int или float

def custom_sum_1(*args: int | float, **kwargs: Dict[Any, int | float]) -> int | float:
    if all(map(lambda x: type(x) in (int, float), (*args, *kwargs.values()))): 
        return sum((*args, *kwargs.values()))
    else:
        raise TypeError('В функцию необходимо передать целое или вещественное число.')


print(custom_sum_1(1, 2, 3, num4=5, num5=6))

# -> 17

# 2. Объявлены 4 обязательных аргумента, а также оставлена возможность для
# передачи неопределенного количества позиционных и именованных аргументов 

def custom_sum_2(num_1: int, num_2: int, num_3: int, num_4: int,\
            *args: int | float, **kwargs: Dict[Any, int | float]):
    if all(map(lambda x: type(x) in (int, float), (num_1, num_2, num_3,\
                                       num_4, *args, *kwargs.values()))): 
        return sum((num_1, num_2, num_3, num_4, *args, *kwargs.values()))
    else:
        raise TypeError('В функцию необходимо передать целое или вещественное число.')

# вызов функии с 4мя обязательными и некоторым числом необязательных аргументов:
print(custom_sum_2(1, 2, 3, 4, 6, 7, 8, num5 = 2, num_10 = 19))

# -> 52

# вызов функции только с одним аргументом
print(custom_sum_2(1))

# -> получаем исключение Type Error, т.к. передан только один аргумент,
# из 4х обязательных

# вызов функции с передачей позиционного аргумента, который дублируется также
# передачей по ключу
print(custom_sum_2(1, 2, 3, 4, num_1=5))

# -> получаем исключение TypeError: got multiple values for argument 'num_1' 
# ошибка связана с тем, что функция уже получает num_1, который является 
# позиционным, и одновременно мы пытаемся передать еще одно значение, но уже с
# прямым указанием на наименование переменной внутри функции. Интерпретатор
# видит два значения для одного и тогоже аргумента и вызывает исключение

# создание кортежа со значениями, передача кортежа в качестве аргумента с 
# указанием оператора распаковки. Для наглядности использовал кортеж как из
# 4х значений, так и кортеж с большим количеством элементов
vals_1 = (1, 2, 3, 4)
vals_2 = (2, 3, 4, 5, 6, 7, 8, 9, 0)

print(custom_sum_2(*vals_1))

# -> 10
# в данном случае происходит распаковка кортежа и 4 элемента из него 
# прокидываются в функцию в качестве обязательных позиционных аргументов, код
# выполняется, функция возвращает значение

print(custom_sum_2(*vals_2))

# -> 44
# здесь также происходит распаковка кортежа, первые 4 элемента которого
# прокидываются в качестве обязательных позиционных аргументов, остальные уходят 
# в кортеж args, который также распаковывается в функции sum

# создание словаря со значениями и распаковка при вызове функции при помощи
# * и ** 

vals_3 = {'num_1': 5, 'num_2': 4, 'num_3': 7, 'num_4': 6}
vals_4 = {'num_1': 5, 'num_2': 4, 'num_3': 7, 'num_4': 6,
          'num_5': 5, 'num_6': 4, 'num_7': 7, 'num_8': 6}

print(custom_sum_2(*vals_3))
print(custom_sum_2(*vals_4))

# -> получаем TypeError, которое вызывается в результате проверки типов значений,
# переданных в функцию. Распаковка словаря при помощи * возвращает ключи данного 
# словаря. Поскольку ключи являются строками - проверка типов не проходит, all()
# возвращает False, вызывается исключение. Тоже самое происходит и при распаковке
# словаря с количеством значений, большим, чем количество обязательных аргументов 
# в функции, с тем отличием, что оставшиеся элементы передаются в args

print(custom_sum_2(**vals_3))
print(custom_sum_2(**vals_4))

# -> 22
# при передаче словаря, в качестве аргумента, с оператором ** происходит распаковка
# его пар ключ-значение и передача их, как аргументов с их наименованием.
# num_1 = 5, num_2 = 4, num_3 = 7, num_4 = 6 и т.д. Далее функция выполняется и
# возвращается сумма всех элементов. В случае со словарем, у которого значений
# больше, чем обязательных аргументов, оставшиеся пары передаются в функцию через
# kwargs

####################################################################################

# HARD

# 1. Функция, принимающая произвольное количество позиционных и именованных
# аргументов возвращает сумму двух случайных элементов. Один из args, второй 
# из kwargs. Проверка типов передаваемых аргументов по-прежнему на месте

def custom_sum_1(*args: int | float, **kwargs: Dict[Any, int | float]) -> int | float:
    if all(map(lambda x: type(x) in (int, float), (*args, *kwargs.values()))):
        temp_cont = (choice(args), choice(list(kwargs.values())))
        return sum(temp_cont)
    else:
        raise TypeError('В функцию необходимо передать целое или вещественное число.')


print(custom_sum_1(1, 2, 3, num4=5, num5=6))

# -> случайные варианты ответа: 6, 8, 7, 9 и т.д.

# 2. В функции суммирования с 4мя обязательными аргументами, берутся все
# обязательные позиционные аргументы, два аргумента из необязательных(args)
# в виде среза, а также один (случайный) именованный аргумент


def custom_sum_2(num_1: int, num_2: int, num_3: int, num_4: int,\
            *args: int | float, **kwargs: Dict[Any, int | float]):
    if all(map(lambda x: type(x) in (int, float), (num_1, num_2, num_3,\
                                       num_4, *args, *kwargs.values()))):
        return sum((num_1, num_2, num_3, num_4, *args[:2], choice(list(kwargs.values()))))
    else:
        raise TypeError('В функцию необходимо передать целое или вещественное число.')

print(custom_sum_2(1, 2, 3, 4, 6, 7, 8, num5 = 2, num_10 = 19))

