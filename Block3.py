from typing import Callable, Any
from functools import wraps
import time

# Задача 1

## 1.1. Декоратор, выводящий сообщение "Покупайте нашиз
## котиков" перед результатом работы функции.

def buy_kitty(func):
    '''Выводит перед результатом декорируемой функции сообщение'''
    @wraps(func)
    def wrapper(*args, **kwargs):
        print('Покупайте наших котиков!')
        res = func(*args, **kwargs)
        return res
    return wrapper

## 1.2. Тот же декоратор , но с возомжностью передать сообщение для вывода на
## экран в виде параметра

def info_mes_with_par(text: str):
    '''Выводит перед результатом декорируемой функции сообщение'''
    def decorator(func):
        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any):
            print(text)
            res = func(*args, **kwargs)
            return res
        return wrapper
    return decorator

# Задача 2

## 2.1. Декоратор который выполняет внутри себя функцию и возвращает рузультат
## в случае успешного выполнения. В противном случае повторяет выполнение
## функции не более 10 раз. Возвращает исключение, если функция не выполнилась
## удачно


def retry(func):
    '''В случае неудачного выполнения функции запускает ее повторно 10 раз.'''
    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        for attempt in range(10):
            print(f'Попытка выполнения функцкции {attempt + 1}')
            try:
                res = func(*args, **kwargs)
                return res
            except Exception as err:
                excep = err
                continue
        if excep:
            raise excep
    return wrapper

## 2.2. Тот же декоратор, но с возможностью передать количество попыток исполнения
## функции в качестве аргумента


def retry_with_par(retries: int):
    '''
    В случае неудачного выполнения функции запускает ее повторно. 
    Количество повторов можно задать аргументом.
    '''
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(retries):
                try:
                    res = func(*args, **kwargs)
                    return res
                except Exception as err:
                    excep = err
                    continue
            if excep:
                raise excep
        return wrapper
    return decorator

## Опциональный вариант декоратора, который не вызывает исключения, а возвращает
## информационную строку с информацией об ошибке в случае неудачного выполнения


def retry_no_ecx(func):
    '''
    В случае неудачного выполнения функции не возбуждает исключение,
    а возвращает строку с информацией об исключении.
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        for attempt in range(10):
            # этот print просто для того чтобы видеть, что работает логика
            # декоратора в соответствии с заданием
            print(f'Попытка выполнения функции {func.__name__} {attempt + 1}')
            try:
                res = func(*args, **kwargs)
                return res
            except Exception as err:
                excep = err
                continue
        if excep:
            return f'Работа функции завершилась с ошибкой: {excep.__class__.__name__} {excep}'
    return wrapper

# Задача 3
## 3.1. Простой кэширующий декоратор

def cache(func):
    '''
    Кэширует результаты работы функции в словарь. При вызове проверяет
    наличие результата в словаре. В случае отсутствия добавляет результа в словарь.
    '''
    cache = {}
    @wraps(func)
    def wrapper(*args, **kwargs):
        key = f"Наименование функции: {func.__name__}; Аргументы: {args}, {kwargs}."
        res = cache.get(key)
        if res is None:
            res = func(*args, **kwargs)
            cache.setdefault(key, res)
        return res
    return wrapper

# 3.2. Кэширующий декоратор с ограничением времени существования кэша, до 10 сек.
## Не уверен в правильности решения, алгоритм проверки ttl кэша придумывал сам.
## По задумке после формирования ключа для текущих параметров функции ставится точка
## отсчета check_ttl, далее c помощью dict.get() запрашиваем значение для функции.
## Если get() возвращает None - сохраняем результат и точку отсчета для ttl кэша 
## (setdefault) функции именно с этими параметрами и возвращаем результат.
## Если get() возвращает значение и при этом (точка отсчета ttl - check_ttl) больше,
## чем ttl - результат из кэша удаляем, возвращаем результат работы функции. 
## Если get() возвращает значение и при этом (точка отсчета ttl - check_ttl) меньше,
## чем ttl - просто возвращаем результата из кэша.
## Протестировал работу декоратора при помощи sleep и print в блоках elif
## который должны сработать в зависимости от текущего времени жизни. Ttl для 
## каждого элемента в словаре учитывается отдельно, а не для вообще всех элементов.

def cache_ttl(func):
    '''
    Декоратор, кэширующий результат выполнения функции в словарь.
    Каждый кэшированный результат имеет точку отсчета ttl. Проверяет ttl 
    значения для декорируемой функции, при истечении - удаляет значение.
    '''
    cache = {}
    ttl = 10
    @wraps(func)
    def wrapper(*args, **kwargs):
        key = f'Наименование функции: {func.__name__}; Аргументы: {args}, {kwargs}.'
        check_ttl = time.time()
        res = cache.get(key)
        if res is None:
            res = func(*args, **kwargs)
            cache.setdefault(key, [res, time.time()])
            print(cache)
        elif res and abs(res[-1] - check_ttl) > ttl:
            del cache[key]
            res = res[0]
        elif res and abs(res[-1] - check_ttl) <= ttl:
            res = res[0]
        return res
    return wrapper

## 3.3. Тот же декоратор, но с возможностью задать ttl в качестве аргумента

def cache_ttl_with_par(ttl: int):
    '''
    Декоратор, кэширующий результат выполнения функции в словарь.
    Каждый кэшированный результат имеет точку отсчета ttl. Проверяет ttl 
    значения для декорируемой функции, при истечении - удаляет значение.
    '''
    def decorator(func):
        cache = {}
        @wraps(func)
        def wrapper(*args, **kwargs):
            key = f'Наименование функции: {func.__name__}; Аргументы: {args}, {kwargs}.'
            check_ttl = time.time()
            res = cache.get(key)
            if res is None:
                res = func(*args, **kwargs)
                cache.setdefault(key, [res, time.time()])
                # print для отображения работы этого блока
                print('Сохраняем значение в кэш')
            elif res and abs(res[-1] - check_ttl) > ttl:
                del cache[key]
                # print для отображения работы этого блока
                print('Удаляем значение из кэша')
                res = res[0]
            elif res and abs(res[-1] - check_ttl) <= ttl:
                # print для отображения работы этого блока
                print('Берем значение из кэша')
                res = res[0]
            return res
        return wrapper
    return decorator


# Задача 4

## 4.1. Декоратор, который измеряет время работы функции и выводит его на экран
## Добавил sleep специально, чтобы отображалось время отличное от 0.0. Почему
## на моей системе round не давал результата, если не было sleep в 1 секунду

def perf_counter(func):
    '''Измеряет время работы функции. Выводит строку с временем работы.'''
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        res = func(*args, **kwargs)
        time.sleep(1)
        end = time.perf_counter()
        working_time = end - start
        print(f'Время выполнения функции составило: {round(working_time, 4)} сек.')
        return res
    return wrapper

## 4.2. Тот же декоратор, но также выводит имя функции, время выполнения которой
## измерялось


def perf_counter_with_name(func):
    '''
    Измеряет время работы функции. Выводит строку с именем функции и 
    временем работы.    
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        res = func(*args, **kwargs)
        time.sleep(1)
        end = time.perf_counter()
        working_time = end - start
        print(
            f'Время выполнения функции {func.__name__} составило: {round(working_time, 4)} сек.')
        return res
    return wrapper

## 4.3. Параметризованный декоратор, отслеживающий время выполнения и логирующий
## данные в файл. Путь к файлу передается в качестве аргумента.


def perf_counter_to_file(path_to_file: str):
    '''
    Измеряет время работы функции и сохраняет результаты измерений в файл.
    Возвращает результат работы декорируемой фукнции.
    '''
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start = time.perf_counter()
            res = func(*args, **kwargs)
            time.sleep(1)
            end = time.perf_counter()
            working_time = end - start
            with open(path_to_file, 'a', encoding='UTF-8') as f:
                print(
                    f'''Время выполнения функции {func.__name__} составило: {round(working_time, 4)} сек.''', file=f
                    )
            return res
        return wrapper
    return decorator


# Задача 6

## 6.1. Декоратор, который запрашивает ввод пароля для выполнения декорируемой функции.

def lock_func(func):
    '''
    Заправшивает пароль для выполнения функции. В случае неверного ввода
    пароль запрашивается циклически, 3 раза. После прекращает выполнение функции.
    '''
    pswd = '1111'

    @wraps(func)
    def wrapper(*args, **kwargs):
        attempts = 2
        user_inp = input('Пожалуйста, введите пароль (всего 3 попытки):\n')
        while user_inp != pswd:
            if attempts > 0:
                user_inp = input(
                    f'''Пароль неверный, повторите попытку (осталось {attempts} попытки(а)):\n'''
                    )
                attempts -= 1
            elif not attempts:
                print('Пароль неверный! Обратитесь к администратору.')
                return ''
        res = func(*args, **kwargs)
        return res
    return wrapper

## 6.2. Тот же декоратор, но с возможностью передать пароль в виде аргумента

def lock_func_with_param(pswd):
    '''
    Заправшивает пароль для выполнения функции. В случае неверного ввода
    пароль запрашивается циклически, 3 раза. После прекращает выполнение функции.
    Пароль можно задать передачей аргумента.
    '''
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 2
            user_inp = input('Пожалуйста, введите пароль (всего 3 попытки):\n')
            while user_inp != pswd:
                if attempts > 0:
                    user_inp = input(
                        f'''Пароль неверный, повторите попытку\
                        (осталось {attempts} попытки(а)):\n'''
                        )
                    attempts -= 1
                elif not attempts:
                    print('Пароль неверный! Обратитесь к администратору.')
                    return ''
            res = func(*args, **kwargs)
            return res
        return wrapper
    return decorator

# Задача 7
## 7.1. Декоратор, который после выполнения функции возвращает результат и записывает
## его в файл

def logger(func):
    '''Сохраняет результат выполнения функции в текстовый файл.'''
    @wraps(func)
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        filename = f'{func.__name__}_log.txt'
        kwarg = {k: v for k, v in kwargs.items()} if kwargs else None
        with open(filename, 'a', encoding='UTF-8') as f:
            print(
                f'Функция <{func.__name__}> выполнена с позиционными аргументами: {args} и именованными аргументами: {kwarg}\
и возвратила результат: {res.__class__.__name__}: {res}', file=f
                )
        return res
    return wrapper

## 7.2. Тот же декоратор, но также логирует возникающие исключения.

def logger_with_exc(func):
    '''
    Сохраняет результат выполнения функции (в том числе исключения)
    в текстовый файл.
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        filename = f'{func.__name__}_log.txt'
        kwarg = {k: v for k, v in kwargs.items()} if kwargs else None
        try:
            res = func(*args, **kwargs)
            with open(filename, 'a', encoding='UTF-8') as f:
                print(
                    f'Функция <{func.__name__}> выполнена с позиционными аргументами: {args} и именованными\
аргументами: {kwarg} и возвратила результат: {res.__class__.__name__}: {res}', file=f
                    )
            return res
        except Exception as err:
            with open(filename, 'a', encoding='UTF-8') as f:
                print(
                    f'Функция <{func.__name__}> запущена с позиционными аргументами: {args} и именованными\
аргументами: {kwarg}. Возбуждено исключение: {err.__class__}: {err}', file=f
                    )
            raise err
    return wrapper


# Задача 5

@perf_counter
@lock_func
@buy_kitty
def greet(name: str) -> str:
    """Приветствует пользователя по имени, возвращает строку."""
    return f'Здравствуйте, {name}!'

names = ['Анна', 'Владимир', 'Антон', 'Валерий']
[print(greet(names[i])) for i in range(0, len(names))]

## Применил написанные декораторы для: (1)вывода сообщения на экран перед выводом 
## результата работы самой функции, (2)установки пароля и (3)счетчика времени работы
## С этим набором декораторов, только для декоратора perf_counter имеет зна-
## чение его положение в порядке работы. В варианте выше он учитывает
## время работы не только декорируемой функции, но и других функций-декораторов
## На решении пратикческих задач это может повлиять на полученные результаты и
## их интерпретацию. Если нам нужно измерить время работы именно декорируемой функции
## perf_counter следует разместить сразу над строкой её объявления.

## В остальном, порядок выполнения я вижу следующим: 
## 1. запуск программы, вычисление декораторов;
## 2. вызов декорированной функции greet в списочном выражении;
## 3. начало работы perf_counter, точка отсчета для вычисления времени работы;
## 4. вызов функции из скоупа perf_counter. При этом из perf_counter
##    вызывается не просто функция greet, а следующий декоратор - lock_func,
##    который в свою очередь запрашивает пароль. По сути, этот пароль нужен 
##    для дальнейшего вызова декоратора buy_kitty. Это не влияет на результат
##    работы этих 3х декораторов, но процессы под капотом все же разные;
## 5. lock_func запрашивает пароль и проверяет его. Если верный - происходит
##    вызов следующего декоратора - buy_kitty. Если неверный - то будет про-
##    должать работать логика декоратора lock_func;
## 6. вызывается buy_kitty и далее выводится сообщение "Покупайте наших котиков!"
## 7. из скоупа buy_kitty вызывается наша декорированная функция greet;
## 8. функция greet выполняет свой код и возвращает результат работы - строку с
##    приветствием. Важно, что данная строка возвращается в скоуп декоратора 
##    buy_kitty;
## 9. в buy_kitty нет дополнительной логики и этот декоратор возвращает результат
##    работы в скоуп lock_func;
## 10. lock_func также не имеет дополнительной логики и возвращает результат работы
##    greet в скоуп per_counter;
## 11. perf_counter в свою очередь после получения результата работы от предыдущего
##    декоратора имеет логику - фиксация окончания времени выполнения функции и
##    декораторов и потом вычисляет само время работы. Вычисленное время выводит
##    на экран;
## 12. после этого res из perf_counter возвращается в функцию print в списочном
##    выражении. Результат работы greet выводится на экран. 

## Далее цикл повторяется по мере обхода всех имен в списке names, при выполнении
## списочного выражения. В итоге, процесс выполнения декораторов как бы падает
## сверху вниз, от верхнего декоратора к нижнему и потом в декорированную функцию,
## а потом результат работы декорируемой функции "выныривает" попутно запуская логику
## других декораторов, написанную после вызова декорируемой функции. Если такая 
## логика есть то происходит ее работа, если нет - результат работы функции
## продолжает движение к самому верхнему декоратору и уже из его скоупа
## мы получаем наш результат работы функции.

## Весь процесс описал так, как увидел его при работе с дебаггером на примере
## функции greet выше. Допускаю, что мог в чем-то ошибиться или неправильно 
## понять то, что показал дебаггер. Если что-то неправильно понимаю - очень
## надеюсь на твои комментарии. 

@lock_func
@buy_kitty
@perf_counter
def greet(name: str) -> str:
    """Приветствует пользователя по имени, возвращает строку."""
    return f'Здравствуйте, {name}!'

names = ['Анна', 'Владимир', 'Антон', 'Валерий']
[print(greet(names[i])) for i in range(0, len(names))]

## В этом наборе декораторов если поменять какие-либо из них местами, то 
## изменится и схема вызова-возврата функций - декораторов и самой декорируемой
## При этом, порядок вызова декораторов из этого набора окажет влияние только 
## на работу perf_counter, который посчитает время работы не greet, buy_kitty
## и lock_func. Если расположить perf_counter над greet - мы получим время
## выполнения только функции greet. В остальном последовательность событий 
## будет полностью укладываться в логику работы кода из предыдущего примера.

@logger_with_exc
@retry_no_ecx
def greet(name: str) -> str:
    """Приветствует пользователя по имени, возвращает строку."""
    if name[0] == 'А':
        return f'Здравствуйте, {name}!'
    else:
        raise ValueError('Недопустимое имя.')

names = ['Анна', 'Владимир', 'Антон', 'Валерий']
[print(greet(names[i])) for i in range(0, len(names))]

## Также добавил этот блок для того чтобы показать работу декораторов,
## retry и logger, которые работают с исключениями. 
